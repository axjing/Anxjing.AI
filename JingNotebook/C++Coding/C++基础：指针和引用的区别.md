<!--
 * @Author: Anxjing.AI
 * @Date: 2020-07-25 16:52:43
 * @LastEditTime: 2020-07-28 20:07:59
 * @LastEditors: Anajing.AI
 * @Description: 
 * @FilePath: \Anxjing.AI\JingNotebook\C++Coding\C++基础：指针和引用的区别.md
 * @THIS FILE IS PART OF Anxjing.AI PROJECT
--> 
#**C++基础：指针和引用的区别**
*例 
```C++
int a;
int &b = a;
```
其中b是a的引用,b引用了a，a被b引用。b 相当于 a 的别名（绰号），对 b 的任何操作就是对a的操作。所以b既不是a的拷贝，也不是指向a的指针，其实b就是a它自己。

* 引用的规则：

    1. 引用被创建的同时必须被初始化（指针则可以在任何时候被初始化）。
    2. 不能有 NULL 引用，引用必须与合法的存储单元关联（指针则可以是 NULL）。
    3. 一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）。

引用的主要功能是传递函数的参数和返回值。

C++ 语言中，函数的参数和返回值的传递方式有三种：值传递、指针传递和引用传递。


1. 成员函数的值传递 

```C++
void FuncV(int x) 
{ 
    x = x + 10; 
} 
... 
int n = 0; 
Func1(n); 
cout << "n = " << n << endl; // n = 0 
```
由于 FuncV 函数体内的 x 是外部变量 n 的一份拷贝，改变 x 的值不会影响 n, 所以 n 的值仍然是 0。

2. 成员函数的指针传递

```C++
void FuncP(int *x) 
{ 
    (* x) = (* x) + 10; 
} 
... 
int n = 0; 
Func2(&n); 
cout << "n = " << n << endl; // n = 10 
```
由于 FuncP 函数体内的 x 是指向外部变量 n 的指针，改变该指针的内容将导致 n 的值改变，所以 n 的值成为 10。

3. 成员函数的引用传递
```C++
void FuncR(int &x) 
{ 
    x = x + 10; 
} 
... 
int n = 0; 
Func3(n); 
cout << "n = " << n << endl; // n = 10
```
由于 FuncR 函数体内的 x 是外部变量 n 的引用，x 和 n 是同一个东西，改变 x 等于改变 n，所以 n 的值成为 10。

## 总结

对比引用传递、值传递和指针传递的示例可知，引用传递和指针传递的性质基本一样，而引用的传递调用方式更像"值传递"。

引用传递与指针传递的功能相似。

但指针能够毫无约束地操作内存中的任何东西，虽然指针功能强大，但是非常危险。

在程序中如果只需要借用一下程序的别名尽量用引用传递。